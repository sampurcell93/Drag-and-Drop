// Generated by CoffeeScript 1.6.3
(function() {
  $(document).ready(function() {
    /* 
        MUST be bound to the window, so as not to leak into 
        global namespace and still have access to other scripts
    */

    window.models = {};
    window.views = {};
    window.collections = {};
    window.models.Element = Backbone.Model.extend({
      defaults: function() {
        return {
          "child_els": new collections.Elements(),
          "inFlow": true
        };
      },
      url: function() {
        var url;
        url = "/section/";
        url += this.id != null ? this.id : "";
        return url;
      },
      modelify: function(child_els) {
        var self, temp;
        self = this;
        temp = new collections.Elements();
        _.each(child_els, function(model) {
          var tempModel;
          temp.add(tempModel = new models.Element(model));
          return tempModel.set("child_els", self.modelify(tempModel.get("child_els")));
        });
        return temp;
      },
      parse: function(response) {
        response.child_els = this.modelify(response.child_els);
        return response;
      },
      blendModels: function(putIn) {
        var children;
        if (putIn.collection != null) {
          putIn.collection.remove(putIn);
        }
        children = this.get("child_els");
        if (children != null) {
          return this.set("child_els", children.add(putIn));
        }
      }
    });
    window.collections.Elements = Backbone.Collection.extend({
      model: models.Element,
      url: '/section/',
      reorder: function(newIndex, originalIndex, collection) {
        var temp;
        console.log(originalIndex, newIndex);
        collection = collection || this;
        temp = collection.at(originalIndex);
        collection.remove(temp, {
          sortableItemRender: false
        });
        collection.add(temp, {
          at: newIndex
        });
        return this;
      }
    });
    window.views.ElementOrganizer = Backbone.View.extend({
      initialize: function() {
        var that;
        this.controller = this.options.controller;
        this.wrapper = $(".control-section").eq(this.controller.index);
        this.$el = this.wrapper.find(".organize-elements");
        this.collection = this.options.collection;
        this.listenTo(this.collection, {
          "add": function(model, collection, options) {
            return that.append(model, options);
          }
        });
        /* Render the list, then apply the drag and drop, and sortable functions.*/

        _.bindAll(this, "append", "render");
        that = this;
        this.$el.sortable({
          axis: 'y',
          tolerance: 'touch',
          connectWith: 'ul',
          containment: 'parent',
          handle: '.sort-element',
          items: 'li',
          start: function(e, ui) {
            return that.origIndex = $(ui.item).addClass("moving-sort").index();
          },
          stop: function(e, ui) {
            return that.collection.reorder($(ui.item).removeClass("moving-sort").index(), that.origIndex);
          }
        });
        return this;
      },
      render: function(e) {
        var $el, index, outOfFlow, that;
        console.log("rendering organizer");
        $el = this.$el;
        $el.children().remove();
        that = this;
        outOfFlow = [];
        index = that.options.index || sectionIndex;
        _.each(this.collection.models, function(el) {
          if (el.get("inFlow") === false) {
            outOfFlow.push(el);
            return;
          }
          return that.append(el, {
            index: index,
            outOfFlow: false
          });
        });
        _.each(outOfFlow, function(out, i) {
          return that.append(out, {
            outOfFlow: true,
            index: index
          });
        });
        return this;
      },
      append: function(element, options) {
        var itemView, opts;
        if (options.at != null) {
          return this;
        }
        opts = this.options;
        opts.model = element;
        $.extend(opts, options);
        itemView = new views.SortableElementItem(opts);
        return this.$el.append(itemView.render().el);
      }
    });
    window.views.SortableElementItem = Backbone.View.extend({
      tagName: 'li class="property"',
      template: $("#element-sortable-item").html(),
      initialize: function() {
        var that;
        that = this;
        this.listenTo(this.model, {
          "render": this.render,
          "destroy": this.remove,
          "remove": function(model, collection, opts) {
            if (opts.sortableItemRender === false) {
              return;
            }
            return that.remove();
          },
          "change:customText": function(model) {
            return that.$el.children(".element-title").first().text(model.get("customText"));
          },
          "change:customHeader": function(model) {
            return that.$el.children(".element-title").first().text(model.get("customHeader"));
          },
          "change:inFlow": function(model) {
            if (model.get("inFlow") === false) {
              return this.$el.addClass("out-of-flow");
            } else {
              return this.$el.removeClass("out-of-flow");
            }
          }
        });
        return this.listenTo(this.model.get("child_els"), {
          "add": this.render,
          "remove": this.render,
          "change:inFlow": this.render
        });
      },
      render: function() {
        var $el, childList, that;
        console.log("rendering item in organizer");
        $el = this.$el;
        $el.html(_.template(this.template, this.model.toJSON()));
        that = this;
        if (this.model.get("inFlow") === false) {
          $el.addClass("out-of-flow");
          $("<div />").addClass("activate-element").text("m").prependTo($el);
          $("<div />").addClass("destroy-element").text("g").prependTo($el);
        } else {
          $el.removeClass("out-of-flow");
        }
        this.outOfFlow = [];
        _.each(this.model.get("child_els").models, function(el) {
          return that.append(el);
        });
        childList = $el.children(".child-list");
        if (childList.children().length > 1) {
          childList.sortable({
            items: 'li',
            axis: 'y',
            containment: 'parent',
            start: function(e, ui) {
              return that.origIndex = $(ui.item).index();
            },
            stop: function(e, ui) {
              console.log(that.options.index);
              return that.model.get("child_els").reorder($(ui.item).index(), that.origIndex);
            }
          });
        }
        return this;
      },
      append: function(child, opts) {
        var $el, childList;
        $el = this.$el;
        childList = $el.children(".child-list");
        opts = {
          model: child,
          child: true,
          index: this.options.index || sectionIndex
        };
        if (child.get("inFlow") === false) {
          opts.outOfFlow = true;
          $el.addClass("out-of-flow");
          $("<div />").addClass("activate-element").text("m").prependTo($el);
          $("<div />").addClass("destroy-element").text("g").prependTo($el);
        }
        return childList.append(new views.SortableElementItem(opts).render().el);
      },
      events: {
        "mousedown .sort-element": function(e) {
          return this.model.trigger("dragging");
        },
        "mouseup .sort-element": function(e) {
          return this.model.trigger("dropped");
        },
        "click .activate-element": function() {
          return this.model.set("inFlow", true);
        },
        "click .destroy-element": function() {
          return this.model.destroy();
        }
      }
    });
    /* A configurable element bound to a property or page element
        Draggable, droppable, nestable.
    */

    window.views.draggableElement = Backbone.View.extend({
      template: $("#draggable-element").html(),
      controls: $("#drag-controls").html(),
      tagName: 'div class="builder-element"',
      initialize: function() {
        var self;
        self = this;
        this.index = this.options.index;
        this.builder = this.options.builder;
        _.bindAll(this, "render", "bindDrop", "bindDrag", "setStyles");
        this.listenTo(this.model.get("child_els"), 'add', function(m, c, o) {
          console.log(o);
          return self.appendChild(m, o);
        });
        this.listenTo(this.model, {
          "change:styles": this.render,
          "change:inFlow": function(model) {
            if (model.get("inFlow") === true) {
              return self.$el.slideDown("fast");
            } else {
              return self.$el.slideUp("fast");
            }
          },
          "remove": this.remove,
          "dragging": function(e) {}
        });
        this.bindDrop();
        return this.bindDrag();
      },
      render: function() {
        var $el, children, model, template, that;
        console.log("rendering draggable");
        that = this;
        model = this.model;
        children = model.get("child_els");
        $el = this.$el;
        this.setStyles();
        template = $(model.get("template")).html() || this.template;
        $el.html(_.template(template, model.toJSON())).append(_.template(this.controls, {}));
        if (children != null) {
          _.each(children.models, function(el) {
            return that.appendChild(el, {});
          });
        }
        return this;
      },
      appendChild: function(child, opts) {
        var draggable, i;
        if (child.get("inFlow") === true) {
          i = this.index || sectionIndex;
          draggable = new views.draggableElement({
            model: child,
            index: i
          }).render().el;
          if ((opts != null) && (opts.at == null)) {
            return this.$el.append(draggable);
          } else {
            if (this.$el.children(".builder-element").eq(opts.at).length) {
              return this.$el.children(".builder-element").eq(opts.at).before(draggable);
            } else {
              return this.$el.children(".builder-element").eq(opts.at - 1).after(draggable);
            }
          }
        }
      },
      setStyles: function() {
        var styles;
        styles = this.model.get("styles");
        if (styles != null) {
          return this.$el.css(styles);
        }
      },
      bindDrag: function() {
        var cancel, that;
        that = this;
        cancel = ".config-menu-wrap, input, textarea";
        cancel += this.options.child != null ? "" : ", .child";
        return this.$el.draggable({
          cancel: cancel,
          revert: "invalid",
          cursor: "move",
          start: function(e, ui) {
            var builder, sect_interface, section;
            sect_interface = allSections.at(that.index || sectionIndex);
            section = sect_interface.get("currentSection");
            builder = sect_interface.get("builder");
            $(ui.helper).addClass("dragging");
            if (builder != null) {
              builder.currentModel = that.model;
              builder.fromSideBar = false;
              return console.log;
            }
          },
          stop: function(e, ui) {
            return $(ui.helper).removeClass("dragging");
          }
        });
      },
      bindDrop: function() {
        var that;
        that = this;
        return this.$el.droppable({
          greedy: true,
          tolerance: 'pointer',
          revert: 'invalid',
          accept: '*',
          over: function(e) {
            return $(e.target).addClass("over");
          },
          out: function(e) {
            return $(e.target).removeClass("over");
          },
          drop: function(e, ui) {
            var builder, draggingModel, flow, model, sect_interface, section;
            sect_interface = allSections.at(that.index || sectionIndex);
            section = sect_interface.get("currentSection");
            builder = sect_interface.get("builder");
            /* Deals with the actual layout changes*/

            $(e.target).removeClass("over");
            draggingModel = builder.currentModel;
            flow = draggingModel.get("inFlow");
            if ((flow === false || typeof flow === "undefined") || builder.fromSideBar === false) {
              model = that.model;
              if (draggingModel.collection === that.model.get("child_els")) {
                console.log("same parent");
                return;
              }
              $(ui.helper).remove();
              ui.draggable.data('dropped', true);
              /* Now, we must consolidate models*/

              return model.blendModels(draggingModel);
            } else {
              return alert("That item is already in the page flow.");
            }
          }
        });
      },
      events: {
        "click": function(e) {
          var layout;
          layout = this.model["layout-item"];
          if (e.shiftKey === true) {
            if (layout === false || typeof layout === "undefined") {
              this.$el.trigger("select");
            } else {
              this.$el.trigger("deselect");
            }
            return e.preventDefault();
          }
        },
        "click .set-options": function(e) {
          var $t, dropdown;
          console.log(this.model.get("type"));
          $t = $(e.currentTarget);
          dropdown = $t.children(".dropdown");
          dropdown.fadeToggle(100);
          return e.stopPropagation();
        },
        "click .set-options li": function(e) {
          e.preventDefault();
          return e.stopPropagation();
        },
        "click .remove-from-flow": function(e) {
          this.model.set("inFlow", false);
          e.stopPropagation();
          return e.stopImmediatePropagation();
        },
        "click .config-panel": function(e) {
          var editor;
          console.log(this.model.get("type"));
          return editor = new views.ElementEditor({
            model: this.model,
            view: this
          }).render();
        },
        "select": function(e) {
          this.model["layout-item"] = true;
          return this.$el.addClass("selected-element");
        },
        "deselect": function() {
          this.model["layout-item"] = false;
          return this.$el.removeClass("selected-element");
        },
        "keyup .generic-header": function(e) {
          this.model.set('customHeader', $(e.currentTarget).val());
          return e.stopPropagation();
        },
        "keyup .generic-text": function(e) {
          this.model.set('customText', $(e.currentTarget).val());
          return e.stopPropagation();
        }
      }
    });
    return window.views.SectionBuilder = Backbone.View.extend({
      initialize: function() {
        var $el, that;
        this.controller = this.options.controller;
        this.wrapper = $(".control-section").eq(this.controller.index);
        this.$el = this.wrapper.find("section");
        this.collection = this.options.collection;
        that = this;
        $el = this.$el;
        this.listenTo(this.collection, {
          "add": function(m, c, opts) {
            return that.append(m, opts);
          }
        });
        $el.droppable({
          accept: '.builder-element, li',
          hoverClass: "dragging",
          activeClass: "dragging",
          helper: 'clone',
          revert: 'invalid',
          tolerance: 'pointer',
          drop: function(event, ui) {
            var c, curr;
            curr = that.currentModel;
            if ((curr.get("inFlow") === false || typeof curr.get("inFlow" === "undefined")) || that.fromSideBar === false) {
              c = curr.collection;
              if ((c != null) && c === !that.collection) {
                c.remove(curr);
                curr.set("inFlow", true);
                that.collection.add(curr);
                return ui.draggable.data('dropped', true);
              }
            } else {
              return alert("That element is already on the page!");
            }
          }
        });
        $el.selectable({
          filter: '.builder-element',
          tolerance: 'touch',
          cancel: '.builder-element',
          selecting: function(e, ui) {
            return $(".ui-selecting").trigger("select");
          },
          unselecting: function(e, ui) {
            console.log("unselecting");
            return $(".ui-selecting").trigger("deselect");
          },
          selected: function(e, ui) {
            return $(".ui-selected").trigger("select");
          },
          unselected: function(e, ui) {
            return $(".ui-selectee").trigger("deselect");
          }
        });
        return this.currentModel = null;
      },
      render: function() {
        var $el, that;
        $el = this.$el;
        that = this;
        $el.empty();
        return _.each(this.collection.models, function(element) {
          return that.append(element, {});
        });
      },
      append: function(element, opts) {
        var draggable;
        if (element.get("inFlow") === false) {
          return null;
        }
        draggable = new views.draggableElement({
          model: element,
          index: this.options.index
        }).render().el;
        if ((opts != null) && (opts.at == null)) {
          return this.$el.append(draggable);
        } else {
          if (this.$el.children(".builder-element").eq(opts.at).length) {
            return this.$el.children(".builder-element").eq(opts.at).before(draggable);
          } else {
            return this.$el.children(".builder-element").eq(opts.at - 1).after(draggable);
          }
        }
      }
    });
  });

}).call(this);
